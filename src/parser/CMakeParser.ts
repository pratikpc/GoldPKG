import { existsSync } from 'fs';
import { difference, uniq } from 'lodash';
import path from 'path';

import { LIBNAME } from '../constants';
import {
    ADD_CMAKE_REGEX,
    FIND_CMAKE_REGEX,
    CMAKE_MINIMUM_CMAKE_REGEX,
    PROJECT_NAME_REGEX,
    TARGET_CMAKE_REGEX,
    TOOLCHAIN_CMAKE_REGEX
} from '../constants/regex';
import { AreSame, ToPosixPath } from '../util';
import RemoveAllThatSatisfyRegex from '../util/RemoveAllInRangeByRegex';
import PathToCMakeToolChain from '../vcpkg/CMakeToolchain';
import BaseParser from './BaseParser';

export default class CMakeParser extends BaseParser {
    public Data: string[] = [];
    public Changes = false;

    constructor(FilePath?: string) {
        super('CMakeLists.txt', FilePath);
    }

    private static RemoveBlank(lines: string[]) {
        return lines.filter((line) => line !== '');
    }

    private static RemoveComment(lines: string[]) {
        return lines.filter(
            (line) => !line.startsWith('#')
        );
    }

    public async LoadFile(FilePath?: string) {
        await super.LoadFile(FilePath);
        if (!this.Exists) return;
        this.Data = (await this.Read)
            .split('\n')
            .map((line) => line.trim());
    }

    get ProjectName() {
        const projectNameExtracted = this.Data.map(
            (line: string) => PROJECT_NAME_REGEX.exec(line)
        ).filter(
            (line) => line != null && line.length >= 1
        )[0];
        if (projectNameExtracted != null)
            return projectNameExtracted[1];
        return null;
    }

    get ProjectLine() {
        const matches = this.Data.map((line) =>
            PROJECT_NAME_REGEX.test(line)
        );
        for (
            let line = 0;
            line < this.Data.length;
            line += 1
        )
            if (matches[line]) return line + 1;
        return null;
    }

    private ClearEmptyLinesAtEnd() {
        let line = this.Data.length;
        for (; line >= 0; line -= 1)
            if (this.Data[line] !== '') break;

        this.Data.splice(line, this.Data.length - line + 1);
    }

    get FindLine() {
        const matches = this.Data.map((line) =>
            FIND_CMAKE_REGEX.test(line)
        );
        if (this.ProjectLine == null) return null;
        for (
            let line = this.ProjectLine;
            line < this.Data.length;
            line += 1
        )
            if (matches[line]) return line;
        return this.ProjectLine;
    }

    get CMakeMinimumReqdLine() {
        for (
            let line = 0;
            line < this.Data.length;
            line += 1
        ) {
            const text = this.Data[line];
            if (CMAKE_MINIMUM_CMAKE_REGEX.test(text))
                return line + 1;
        }
        return 0;
    }

    get addFunc() {
        return this.Data.map((line) =>
            ADD_CMAKE_REGEX.exec(line)
        ).filter((line) => line != null)[0];
    }

    public setCMakeToolChainLine() {
        // Only Set CMake ToolChain if the CMakeFiles.txt is in Root Folder
        if (
            !this.Exists ||
            !existsSync(
                path.join(this.DirName, 'vcpkg.json')
            )
        )
            return;
        let existingToolChainPath: string[] = [];
        [
            this.Data,
            existingToolChainPath
        ] = RemoveAllThatSatisfyRegex(
            this.Data,
            TOOLCHAIN_CMAKE_REGEX,
            this.CMakeMinimumReqdLine,
            // Parse Top to Down
            'DOWN'
        );
        existingToolChainPath = CMakeParser.RemoveBlank(
            existingToolChainPath
        );

        const vcpkgToolChainFilePath = ToPosixPath(
            path.join(
                `\${CMAKE_CURRENT_SOURCE_DIR}`,
                path.relative(
                    this.DirName,
                    PathToCMakeToolChain()
                )
            )
        );
        const insert = [
            '',
            `# AUTOGEN TOOLCHAIN Generated by ${LIBNAME}`,
            `# AUTOGEN TOOLCHAIN Links to LOCAL VCPKG ToolChain File`,
            `set(CMAKE_TOOLCHAIN_FILE ${vcpkgToolChainFilePath} CACHE STRING "Vcpkg toolchain file")`,
            `# AUTOGEN TOOLCHAIN Generation ENDS`,
            ''
        ];
        // Add our Toolchain Line
        // To Integrate CMake with VCPKg
        this.Data.splice(
            this.CMakeMinimumReqdLine,
            0,
            ...insert
        );
        this.Changes =
            this.Changes ||
            !AreSame(
                CMakeParser.RemoveBlank(insert),
                CMakeParser.RemoveBlank(
                    existingToolChainPath
                )
            );
    }

    public RemoveFindAndTarget(): [string[], string[]] {
        this.ClearEmptyLinesAtEnd();
        if (this.FindLine == null) return [[], []];

        const [
            dataFinds,
            finds
        ] = RemoveAllThatSatisfyRegex(
            this.Data,
            FIND_CMAKE_REGEX,
            this.FindLine,
            'DOWN'
        );
        this.Data = dataFinds;
        const [
            dataTargets,
            targets
        ] = RemoveAllThatSatisfyRegex(
            this.Data,
            TARGET_CMAKE_REGEX,
            this.Data.length - 1,
            'UP'
        );
        this.Data = dataTargets;
        return [
            CMakeParser.RemoveBlank(finds),
            CMakeParser.RemoveBlank(targets)
        ];
    }

    // Add find and target params
    public InsertFindAndTarget(
        finds: string[],
        targets: string[],
        removeFinds: string[] = [],
        removeTargets: string[] = []
    ) {
        if (
            finds.length === 0 &&
            targets.length === 0 &&
            removeFinds.length === 0 &&
            removeTargets.length === 0
        )
            return;

        const [
            existingFinds,
            existingTargets
        ] = this.RemoveFindAndTarget();

        let findsInsert = CMakeParser.RemoveComment(
            CMakeParser.RemoveBlank(
                uniq(
                    difference(
                        [...finds, ...existingFinds],
                        removeFinds
                    )
                )
            )
        );

        // Add Find_* Below Package Line
        if (findsInsert.length !== 0) {
            findsInsert = [
                '',
                `# AUTOGEN FIND COMMANDS GENERATED BY ${LIBNAME}`,
                `# AUTOGEN FIND PLEASE DO NOT MODIFY`,
                ...findsInsert,
                `# AUTOGEN FIND LIBRARY WILL LOOK FOR PACKAGES HERE ONLY`,
                '# AUTOGEN FIND ENDS HERE',
                ''
            ];

            this.Data.splice(
                Number(this.ProjectLine),
                0,
                ...findsInsert
            );
        }
        let targetsInsert = CMakeParser.RemoveComment(
            CMakeParser.RemoveBlank(
                uniq(
                    difference(
                        [...targets, ...existingTargets],
                        removeTargets
                    )
                )
            )
        );
        // Add Target to End
        if (targetsInsert.length !== 0) {
            targetsInsert = [
                '',
                `# AUTOGEN TARGET GENERATED BY ${LIBNAME}`,
                `# AUTOGEN TARGET PLEASE DO NOT MODIFY`,
                ...targetsInsert,
                `# AUTOGEN TARGET LIBRARY WILL LOOK FOR PACKAGES HERE ONLY`,
                '# AUTOGEN TARGET ENDS HERE',
                ''
            ];
            this.Data = this.Data.concat(...targetsInsert);
        }
        this.Changes =
            this.Changes ||
            !AreSame(
                CMakeParser.RemoveBlank(findsInsert),
                existingFinds
            ) ||
            !AreSame(
                CMakeParser.RemoveBlank(targetsInsert),
                existingTargets
            );
    }

    async Save() {
        if (!this.Changes) return false;
        if (!this.Exists) return false;
        const data = this.Data.join('\n');
        await this.WriteFile(data);
        return true;
    }
}
